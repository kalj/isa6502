#!/usr/bin/python3
#
#

import sys
import re
import argparse
import isa6502

# ===================================================================
# preprocess
#
# remove comments and empty lines
# ===================================================================

def preprocess(src_in):
    src_out = []
    for i,line in enumerate(src_in):
        idx = line.find(";")
        if idx>=0:
            l = line[:idx]
        else:
            l = line

        l = l.strip()
        if len(l) == 0:
            continue

        src_out.append((l,i))
    return src_out

# ===================================================================
# Harvest labels
# ===================================================================
def harvest_labels(src_in):
    labels={}
    current_labels = []
    src_out = []
    for line,linum in src_in:
        m = re.match("^([a-zA-Z_]\w*):(.*)$",line)
        if m:
            current_labels.append(m.group(1))
            line = m.group(2).strip()

        if line:
            current_idx = len(src_out)
            if current_labels:
                for l in current_labels:
                    labels[l] = current_idx
                current_labels = []

            src_out.append((line,linum))
        # else line was empty, i.e. there was nothin after the label

    if current_labels:
         SyntaxError("Label at end of file")
         raise e

    return src_out,labels

# ===================================================================
# Parse statements (instructions and data directives)
# ===================================================================

def parse_byte(s):
    try:
        if s[0] == "$":
            v = int(s[1:],16)
        else:
            v = int(s)
    except:
        raise SyntaxError("Invalid byte token: {}".format(s))

    if v > 255 or v<-128:
        raise SyntaxError("Integer value of token out of 8-bit range: {}".format(s))

    # convert to unsigned
    v = (v+256) % 256

    return v

def parse_string(s):
   if s[0] != '"' or s[-1] != '"':
       raise SyntaxError("Not a valid ascii string")

   try:
       return s[1:-1].encode()
   except:
       raise SyntaxError("Failed encoding ascii string")

class Data:
    def __init__(self,bs):
        self._bytes = bs

    def size(self):
        return len(self._bytes)

def parse_statement(line):

    if line.startswith(".byte "):
        args = [ a.strip() for a in line[5:].split(",")]
        bytez = bytes([parse_byte(a) for a in args])
        return Data(bytez)

    elif line.startswith(".ascii "):
        # ascii string
        bytez = parse_string(line[6:].strip())
        return Data(bytez)
    elif line.startswith(".asciiz "):
         # null-terminated ascii string
        bytez = parse_string(line[7:].strip())
        return Data(bytez+[0]) # append null byte
    else:
        return isa6502.parse_instruction(line)

def parse_lines(source):
    statements = []
    for line,linum in source:
        try:
            statements.append(parse_statement(line))
        except isa6502.SyntaxError as e:
            e.set_linum(linum)
            raise e

    return statements

def resolve_labels(statements,labels,base_address):

    byte_offset = base_address
    addresses = []

    for stmt in statements:
        addresses.append(byte_offset)
        byte_offset += stmt.size()

    label_addresses = {l:addresses[idx] for l,idx in labels.items()}

    for stmt,addr in zip(statements,addresses):

        if isinstance(stmt,isa6502.Instruction):
            stmt.resolve_label(label_addresses,addr)

    return statements

def encode(instructions):
    ops = []
    for instr in instructions:
        ops.extend(instr.encode())

    return bytes(ops)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='6502 Assembler')
    parser.add_argument('input', help='name of source file to assemble')
    parser.add_argument('-o','--output',
                        default='a.out',
                        help='name of output file')
    parser.add_argument('-b','--base-address',
                        default=0x8000,
                        help='base address offset')

    args = parser.parse_args()

    base_address = args.base_address

    inputfilename=args.input
    outputfilename=args.output

    raw_source = open(inputfilename,"r").readlines()

    # preprocess
    pp_source = preprocess(raw_source)

    try:
        # Harvest labels
        source,labels = harvest_labels(pp_source)

        statements = parse_lines(source)

        statements = resolve_labels(statements,labels,base_address)

    except isa6502.SyntaxError as e:
        linum = e.get_linum()
        if linum:
            print("SyntaxError on line {}: {}".format(linum,str(e)))
            print(raw_source[linum])
        else:
            print("SyntaxError: {}".format(str(e)))
        sys.exit(1)

    prog = encode(statements)

    open(outputfilename,"wb").write(prog)
