#!/usr/bin/python3
#
#

import sys
import re
import argparse
import isa6502

# ===================================================================
# prune
#
# remove comments and empty lines
# ===================================================================

def prune(src_in):
    src_out = []
    for i,line in enumerate(src_in):
        idx = line.find(";")
        if idx>=0:
            l = line[:idx]
        else:
            l = line

        l = l.strip()
        if len(l) == 0:
            continue

        src_out.append((l,i))
    return src_out

# ===================================================================
# preprocess
#
# gather variable definitions, and replaces references with values
# ===================================================================

class PreprocessorError(Exception):
    def __init__(self,message, linum):
        super().__init__(message)
        self._linum = linum

    def get_linum(self):
        return self._linum


def replace_variable_references(s, variables):
    for name in variables:
        val = variables[name]
        s = re.sub(r'\b'+name+r'\b', val,  s)

    return s

def preprocess(src_in):
    variables = {}
    src_out = []
    for line,linum in src_in:

        if m := re.match("^#define ([a-zA-Z_]\w*)\s+(.*)$",line):
            # variable definition
            name = m.group(1)
            if name in variables:
                raise PreprocessorError("Redefinition of variable '{}'".format(name), linum)

            value = m.group(2)
            variables[name] = replace_variable_references(value, variables)
        else:
            line = replace_variable_references(line, variables)
            src_out.append((line,linum))

    return src_out


# ===================================================================
# Harvest labels
# ===================================================================
def harvest_labels(src_in):
    labels={}
    current_labels = []
    src_out = []
    for line,linum in src_in:
        m = re.match("^([a-zA-Z_]\w*):(.*)$",line)
        if m:
            current_labels.append((m.group(1), linum))
            line = m.group(2).strip()

        if line:
            current_idx = len(src_out)
            if current_labels:
                for l,ln in current_labels:
                    if l in labels:
                        e = isa6502.SyntaxError("Duplicate label '{}', first label at {}".format(l,labels[l]['linum']))
                        e.set_linum(ln)
                        raise e
                    labels[l] = {'idx':current_idx, 'linum':ln}
                current_labels = []

            src_out.append((line,linum))
        # else line was empty, i.e. there was nothin after the label

    if current_labels:
        e = isa6502.SyntaxError("Label at end of file")
        e.set_linum(src_in[-1][1])
        raise e

    labels = { k:v['idx'] for k,v in labels.items() }
    return src_out,labels


# ===================================================================
# Parse statements (instructions and data directives)
# ===================================================================

def parse_byte(s):
    try:
        if s[0] == "$":
            v = int(s[1:],16)
        elif s[0] == "%":
            v = int(s[1:],2)
        else:
            v = int(s)
    except:
        raise SyntaxError("Invalid byte token: {}".format(s))

    if v > 255 or v<-128:
        raise SyntaxError("Integer value of token out of 8-bit range: {}".format(s))

    # convert to unsigned
    v = (v+256) % 256

    return v

def parse_string(s):
   if s[0] != '"' or s[-1] != '"':
       raise SyntaxError("Not a valid ascii string")

   try:
       the_string=s[1:-1]
       the_string=the_string.replace('\\n', '\n').replace('\\t', '\t')
       return the_string.encode()
   except:
       raise SyntaxError("Failed encoding ascii string")

class Data:
    def __init__(self,bs):
        self._bytes = bs

    def __str__(self):
        return ".bytes "+str(self._bytes)

    def size(self):
        return len(self._bytes)

    def encode(self):
        return self._bytes

def parse_statement(line):

    if line.startswith(".byte "):
        args = [ a.strip() for a in line[5:].split(",")]
        bytez = bytes([parse_byte(a) for a in args])
        return Data(bytez)

    elif line.startswith(".ascii "):
        # ascii string
        bytez = parse_string(line[6:].strip())
        return Data(bytez)
    elif line.startswith(".asciiz "):
         # null-terminated ascii string
        bytez = parse_string(line[7:].strip())
        return Data(bytez+b'\0') # append null byte
    else:
        return isa6502.parse_instruction(line)

def parse_lines(source):
    statements = []
    for line,linum in source:
        try:
            statements.append(parse_statement(line))
        except isa6502.SyntaxError as e:
            e.set_linum(linum)
            raise e

    return statements

def resolve_labels(statements,labels,base_address):

    byte_offset = base_address
    addresses = []

    for stmt in statements:
        addresses.append(byte_offset)
        byte_offset += stmt.size()

    label_addresses = {l:addresses[idx] for l,idx in labels.items()}

    for stmt,addr in zip(statements,addresses):

        if isinstance(stmt,isa6502.Instruction):
            stmt.resolve_label(label_addresses,addr)

    return statements

def encode(statements):
    ops = []
    for stmt in statements:
        ops.extend(stmt.encode())

    return bytes(ops)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='6502 Assembler')
    parser.add_argument('input', help='name of source file to assemble')
    parser.add_argument('-v','--verbose',
                        action='store_true',
                        help='enable verbose output')
    parser.add_argument('-o','--output',
                        default='a.out',
                        help='name of output file')
    parser.add_argument('-b','--base-address',
                        default=0xa000,
                        help='base address offset')

    args = parser.parse_args()

    base_address = args.base_address

    inputfilename=args.input
    outputfilename=args.output

    raw_source = open(inputfilename,"r").readlines()

    # prune
    source_lines = prune(raw_source)

    try:
        source_lines = preprocess(source_lines)

        # Harvest labels
        source_lines,labels = harvest_labels(source_lines)

        statements = parse_lines(source_lines)

        statements = resolve_labels(statements,labels,base_address)

    except isa6502.SyntaxError as e:
        linum = e.get_linum()
        if linum:
            print("SyntaxError on line {}: {}".format(linum,str(e)))
            print(raw_source[linum].rstrip())
        else:
            print("SyntaxError: {}".format(str(e)))
        sys.exit(1)

    if args.verbose:
        addr = base_address
        source = []
        for s in statements:
            instr_bytes = s.encode()
            bytes_str = " ".join(["{:02x}".format(b) for b in instr_bytes])
            source.append( ("{:04x}".format(addr),bytes_str,str(s)) )
            addr += s.size()
        widths = [max(len(s) for s in strs) for strs in zip(*source)]

        print("Parsed code:")
        for line in source:
            print("{}  {}  {}".format(line[0],line[1].ljust(widths[1]),line[2]))

    prog = encode(statements)

    open(outputfilename,"wb").write(prog)
